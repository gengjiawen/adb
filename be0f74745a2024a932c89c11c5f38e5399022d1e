{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0e771aa0_20b5e4ea",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 91,
      "author": {
        "id": 1076798
      },
      "writtenOn": "2024-06-29T21:51:43Z",
      "side": 1,
      "message": "```suggestion\n// For in-house hotplug, we generate an unique identifier based on device invariant (vendor,\n```\n\n\nAlso, isn\u0027t this not an invariant? The product ID changes based on the USB mode (adb vs adb+mtp, etc.)\n\nAre you encoding this to handle reenumeration when changing modes?",
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "54f55fff_69b30325",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 91,
      "author": {
        "id": 1083168
      },
      "writtenOn": "2024-06-30T20:55:59Z",
      "side": 1,
      "message": "Yes. I improved the comment.",
      "parentUuid": "0e771aa0_20b5e4ea",
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77249032_a90e9ad9",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 93,
      "author": {
        "id": 1076798
      },
      "writtenOn": "2024-06-29T21:51:43Z",
      "side": 1,
      "message": "Isn\u0027t this true for Linux as well?",
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0b6c52f9_b0ef53c9",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 93,
      "author": {
        "id": 1083168
      },
      "writtenOn": "2024-06-30T20:55:59Z",
      "side": 1,
      "message": "I have not checked. I am only interested in Windows here.",
      "parentUuid": "77249032_a90e9ad9",
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a4477cff_463d1152",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 195,
      "author": {
        "id": 1076798
      },
      "writtenOn": "2024-06-29T21:51:43Z",
      "side": 1,
      "message": "```suggestion\n    // When a Windows machine go to sleep it powers off all its USB host controllers to save\n    // energy. When the machine awakens, it powers them up which causes all the endpoints\n    // to be closed (which generates a read/write failure leading to us Close()ing the device). The\n    // USB device also briefly goes away and comes back with the exact same properties (including\n    // address). This makes in-house hotplug miss device reconnection upon wakeup. To solve that\n    // problem, we remove ourselves from the list of known devices when read/write fails.\n```",
      "range": {
        "startLine": 190,
        "startChar": 0,
        "endLine": 195,
        "endChar": 87
      },
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bbeda377_d60e6e92",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 195,
      "author": {
        "id": 1083168
      },
      "writtenOn": "2024-06-30T20:55:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a4477cff_463d1152",
      "range": {
        "startLine": 190,
        "startChar": 0,
        "endLine": 195,
        "endChar": 87
      },
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dbd2b584_ac02d368",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 201,
      "author": {
        "id": 1076798
      },
      "writtenOn": "2024-06-29T21:51:43Z",
      "side": 1,
      "message": "I think there\u0027s a potential race condition here if we went to sleep while doing a write: we\u0027ll get multiple calls to this function, interleaved with the hotplug scan in the middle.\n\nNot sure how likely this is to happen, but it seems cleaner to me to have a queue of \"hotplug left devices\" and handle all of the state in the hotplug loop. (I\u0027m also leery of lock ordering problems here: we get called from a libusb thread here and try to take the inhouse lock, and we call into libusb with the inhouse lock taken in the scanning thread)",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 201,
        "endChar": 50
      },
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4d95bc1_8b0d5288",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 201,
      "author": {
        "id": 1083168
      },
      "writtenOn": "2024-06-30T20:55:59Z",
      "side": 1,
      "message": "\u003e I think there\u0027s a potential race condition here if we went to sleep while doing a write: we\u0027ll get multiple calls to this function, interleaved with the hotplug scan in the middle.\n\nI don\u0027t see how. Multiple calls (if that was to ever happen) would block on the mutex, if the scan is running (the whole scan is guarded by the same lock). When the scan ends, these blocked calls are allowed to resume.\n\n\u003e I\u0027m also leery of lock ordering problems here: we get called from a libusb thread here and try to take the inhouse lock, and we call into libusb with the inhouse lock taken in the scanning thread\n\n`libusb_has_capability(LIBUSB_CAP_HAS_HOTPLUG)` is implemented a `\u003d\u003dnullptr`. There is no risk of locking here. If you really don\u0027t like it, I would also wrap all that in a `#ifdef WIN`, although I would really prefer not to.",
      "parentUuid": "dbd2b584_ac02d368",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 201,
        "endChar": 50
      },
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85953cf3_e7168f2c",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 201,
      "author": {
        "id": 1083168
      },
      "writtenOn": "2024-06-30T21:28:18Z",
      "side": 1,
      "message": "I meant replace the `libusb_has_capability` with `#ifdef`.",
      "parentUuid": "d4d95bc1_8b0d5288",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 201,
        "endChar": 50
      },
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7841c018_ad82420e",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 201,
      "author": {
        "id": 1076798
      },
      "writtenOn": "2024-07-02T08:36:17Z",
      "side": 1,
      "message": "\u003e Multiple calls (if that was to ever happen) would block on the mutex, if the scan is running (the whole scan is guarded by the same lock).\n\nOnly if the scan wins the race. If there\u0027s a read cb, write cb, and scan thread all waiting for the lock, and they get interleaved as read, scan, write, then you die.\n\n\u003e libusb_has_capability(LIBUSB_CAP_HAS_HOTPLUG) is implemented a \u003d\u003dnullptr. There is no risk of locking here.\n\nThat is not what I mean: these callbacks are called from a libusb thread. The hotplug thread might have the hotplug mutex taken and block on a libusb lock while one of these callbacks is being called on a libusb thread that is holding a libusb lock, and block on the hotplug mutex.",
      "parentUuid": "85953cf3_e7168f2c",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 201,
        "endChar": 50
      },
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "37bf309b_1f174439",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 201,
      "author": {
        "id": 1083168
      },
      "writtenOn": "2024-07-03T21:41:10Z",
      "side": 1,
      "message": "\u003eOnly if the scan wins the race. \n\nFrom what I can read in `libusb` source code, the event system (handling hotplug and transfer callbacks) is dissociated from device enumeration. If my understanding is incorrect (citation needed :P), that means `libusb_get_device_list` and the callbacks must never occur at the same tim.\n\nI like your idea to handle everything on the event thread. That would remove the need to create a second thread. What about I move the call to `inhouse_hotplug_scan` just above `libusb_handle_events` (and make `inhouse_hotplug_scan` actually scan every `2s` and otherwise be a noop)? This way, everything happens on libusb event thread. WDYT?",
      "parentUuid": "7841c018_ad82420e",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 201,
        "endChar": 50
      },
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b11194f_75f7e9a7",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 934,
      "author": {
        "id": 1076798
      },
      "writtenOn": "2024-06-29T21:51:43Z",
      "side": 1,
      "message": "Make this just a plain size_t, if it\u0027s actually GUARDED_BY the mutex?\n\n(I don\u0027t remember why I made this atomic)",
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d833778c_7d65a98c",
        "filename": "client/usb_libusb.cpp",
        "patchSetId": 10
      },
      "lineNbr": 934,
      "author": {
        "id": 1083168
      },
      "writtenOn": "2024-06-30T20:55:59Z",
      "side": 1,
      "message": "ACK, will change that in next CL.",
      "parentUuid": "4b11194f_75f7e9a7",
      "revId": "be0f74745a2024a932c89c11c5f38e5399022d1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}