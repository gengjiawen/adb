{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "4c304d24_552d5071",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2020-12-14T19:06:27Z",
      "side": 1,
      "message": "I\u0027m not sure we want sideload to be mentioned in adb\u0027s source, given that it\u0027s not actually implemented in adbd, unless there\u0027s no alternative.\n\nDid you try waiting for the socket to close in SideloadHostService, or does `adb sideload` keep its end open?",
      "revId": "11aedc24953599e703d65ee1f0a55c649140a455",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "189a7325_01eb61ce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1710792
      },
      "writtenOn": "2020-12-14T19:29:59Z",
      "side": 1,
      "message": "How do I wait for a socket to close?",
      "parentUuid": "4c304d24_552d5071",
      "revId": "11aedc24953599e703d65ee1f0a55c649140a455",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5780b402_da21ddc2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2020-12-14T19:30:31Z",
      "side": 1,
      "message": "read until it returns 0",
      "parentUuid": "189a7325_01eb61ce",
      "revId": "11aedc24953599e703d65ee1f0a55c649140a455",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cb603e8a_d8815e90",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1710792
      },
      "writtenOn": "2020-12-14T19:32:52Z",
      "side": 1,
      "message": "That works, but code looks weird to me. In addition, can we read() with timeout?",
      "parentUuid": "5780b402_da21ddc2",
      "revId": "11aedc24953599e703d65ee1f0a55c649140a455",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e898e4a0_28fc561d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2020-12-14T19:51:21Z",
      "side": 1,
      "message": "If you want a timeout, you\u0027ll want to use one of select/poll/epoll (I recommend poll for this, since you\u0027re only waiting on one fd). If poll returns that the fd is readable, read is guaranteed to not block the first time you call it, so you\u0027ll want something that looks like this:\n\n  while (true) {\n    struct pollfd pfd \u003d { .fd \u003d fd, .events \u003d POLLIN };\n    int rc \u003d TEMP_FAILURE_RETRY(poll(\u0026pfd, 1, timeout_ms));\n    if (rc \u003d\u003d 1) {\n      char buf;\n      rc \u003d TEMP_FAILURE_RETRY(read(fd, \u0026buf, 1));\n      if (rc \u003d\u003d 0) {\n        exit(0);\n      } else {\n        // Either the read unexpectedly failed, or we unexpectedly received data.\n      }\n    } else {\n      // poll failed, almost definitely due to timeout\n      // If not, you\u0027re screwed anyway, because it probably means the kernel ran\n      // out of memory.\n      CHECK_EQ(0, rc);\n      // do something here\n    }\n  }",
      "parentUuid": "cb603e8a_d8815e90",
      "revId": "11aedc24953599e703d65ee1f0a55c649140a455",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}